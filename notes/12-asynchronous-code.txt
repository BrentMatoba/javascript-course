Asynchronous code
Introduction:
Since javascriptg is the language of the web, thre are some functions that by necessity are goingt o take a decent
amount of itme to cpmlete, sucha s fetching data from a server to display on your site. For this reason, jagvascdript includes
support for asynchrounous functions, or to put it another way, functions that can happen in the background while the rest of your code executes.

Lesson OVerveiw:
This section contains a general overview of topics you will learn in this lesson. Explain what a callback is
explain what a promise is
explain the circumsttance which promises are better than clalbacks
explain the .then() functions

Callbacks:
In the recent past, the way that these were most commonly handled were with callbacks, and even now they are stil use
quite a lot in certain circumstances.
A callback fucniton is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or aciton.

Callbacks are functions that get passed into other functions.

For example:
    myDiv.addEventListern("click", function()){
    DO SOMETHINGGG
    }

Here, the function addEventListern() takes a callback ("the do something" funciton) and then aclls it when myDiv gest clicked>
YOu will likely recognize htis pattern as something that hpapens all the time in javascript code.
Unfortuantely, though they are useful in situations like the above example,Â using callbacks can get out of hand, especially when you need to chain several of htem together in a specific
order. the rest of htis lesson discusses pattersn and functions that will help keep you out of callback hell.

Promises:
There are multiple ways that you can handle asynchronous code in JavaScrfipt, and they all have their use cases.
Promises are one such mechanism, and they're on you will see somewhat often when using other libraries or frameworks. Knowing 
what thye are and how to use them is quite useful.

Essentially, a promise is an object that might produce a value at some point in the future.

Lets say getData()is a function that fetches some data from a server and retunrs it as on object that we can use in our code:

const getData = function() {
    //go fetch data from some APi
    //clean it up a bit return it as an object
    return data.
}
The issue with this example is that it takes some time to fetche the data, but unless we tell our code that, it assumes that everything in the funciton happens essentially instantly.

So if we try this:
const myData = getData()
const pieceOfData = myData["whatever"]

WE're going to run into trouble because when we try to extract pieceOfData out of the returned data,
the funciton getData() will mostlikely still be fetchingh, so myData will not be the expected data,
but will be undefined. Sad.

We need some way to solve this problem, and tell our code to wait until the data is done fetching to continue. Promises solve this issue. 



const myData = getData() //if this is refactored to return a promise...


myData.then(function(data) [//.,then() tell is to wait until the promise is resolved
    const pieceOfData = data["whatever]//and THEN run the function inside.
])



Article:https://davidwalsh.name/promises

While synchronous code is easeir to follow and debug, async is generally ebtter for performance and flexiibility.
Why "hold up the show" when you can trigger numerous requests at once and then handle them when each si ready?
Promsies are becoming a big part of the javascript world, with many new APIS being implemented witht hep rmose philosophy.


Promises in the wild:
The XMLHttpRequest API is async but does NOT use the promises API. TGhere are a few native apis that now use promises however.
    Battery API
    fetch API
    ServiceWorker API

Promises will only become more prevalent so its important that allf ront-end developers get used to them.
Its also worht noting that node.js is another platform for promises. Obviously as promise is a core language features.

