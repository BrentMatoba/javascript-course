Asynchronous code
Introduction:
Since javascriptg is the language of the web, thre are some functions that by necessity are goingt o take a decent
amount of itme to cpmlete, sucha s fetching data from a server to display on your site. For this reason, jagvascdript includes
support for asynchrounous functions, or to put it another way, functions that can happen in the background while the rest of your code executes.

Lesson OVerveiw:
This section contains a general overview of topics you will learn in this lesson. Explain what a callback is
explain what a promise is
explain the circumsttance which promises are better than clalbacks
explain the .then() functions

Callbacks:
In the recent past, the way that these were most commonly handled were with callbacks, and even now they are stil use
quite a lot in certain circumstances.
A callback fucniton is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or aciton.

Callbacks are functions that get passed into other functions.

For example:
    myDiv.addEventListern("click", function()){
    DO SOMETHINGGG
    }

Here, the function addEventListern() takes a callback ("the do something" funciton) and then aclls it when myDiv gest clicked>
YOu will likely recognize htis pattern as something that hpapens all the time in javascript code.
Unfortuantely, though they are useful in situations like the above example,Â using callbacks can get out of hand, especially when you need to chain several of htem together in a specific
order. the rest of htis lesson discusses pattersn and functions that will help keep you out of callback hell.

Promises:
There are multiple ways that you can handle asynchronous code in JavaScrfipt, and they all have their use cases.
Promises are one such mechanism, and they're on you will see somewhat often when using other libraries or frameworks. Knowing 
what thye are and how to use them is quite useful.

Essentially, a promise is an object that might produce a value at some point in the future.

Lets say getData()is a function that fetches some data from a server and retunrs it as on object that we can use in our code:

const getData = function() {
    //go fetch data from some APi
    //clean it up a bit return it as an object
    return data.
}
The issue with this example is that it takes some time to fetche the data, but unless we tell our code that, it assumes that everything in the funciton happens essentially instantly.

So if we try this:
const myData = getData()
const pieceOfData = myData["whatever"]

WE're going to run into trouble because when we try to extract pieceOfData out of the returned data,
the funciton getData() will mostlikely still be fetchingh, so myData will not be the expected data,
but will be undefined. Sad.

We need some way to solve this problem, and tell our code to wait until the data is done fetching to continue. Promises solve this issue. 



const myData = getData() //if this is refactored to return a promise...


myData.then(function(data) [//.,then() tell is to wait until the promise is resolved
    const pieceOfData = data["whatever]//and THEN run the function inside.
])



Article:https://davidwalsh.name/promises

While synchronous code is easeir to follow and debug, async is generally ebtter for performance and flexiibility.
Why "hold up the show" when you can trigger numerous requests at once and then handle them when each si ready?
Promsies are becoming a big part of the javascript world, with many new APIS being implemented witht hep rmose philosophy.


Promises in the wild:
The XMLHttpRequest API is async but does NOT use the promises API. TGhere are a few native apis that now use promises however.
    Battery API
    fetch API
    ServiceWorker API

Promises will only become more prevalent so its important that allf ront-end developers get used to them.
Its also worht noting that node.js is another platform for promises. Obviously as promise is a core language features.

Basic Promise Usage:
The new Promise() constructor should only be used fo rlegacy async tasks, like the usage of setTimeout or XMLHttpRequest. 
AA new promsie is created with the new keyword and the promise provides resolvea dn reject funcitons to the provided callback:

var p = new Promise(function(resolve, reject) {
	
	// Do an async task async task and then...

	if(/* good condition */) {
		resolve('Success!');
	}
	else {
		reject('Failure!');
	}
});

p.then(function(result) { 
	/* do something with the result */
}).catch(function() {
	/* error : */
}).finally(function() {
   /* executes regardless or success for failure */ 
});



Sometimes you dont NEED to complete an async takss within the promise.
returning a promise will be best so taht you can always count on ap romise coming out of a given fucniton.
IN that case, you acn simply call promise.reolve() of promise.reject() without using the new keyword


Callbacks: https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/async%20%26%20performance/ch2.md

IN chapter 1, we explored the terminology adn concepts around asynchronous programming in javascript.
Our focus is onudnerstandint he single-threaded (one at a time) event lop queue that
drives all events. WE also explored vairous ways that concurrency pattersn explains the relationshipos
between any simultaneously running chains of events, or processes.

All oru examples in chapter 1 use the funciton as the individual, indivisible unit of operations, whereby inside
the funciton, statements run in predictrable order ( above the ocmpiler level) but at the
funciton ordering level, events (aka async funciton invocations) can happen in a variety or ordres.

In all these cases, the funciton is a cting as a "callback" because it serves as the target for the event loop
to "call back into" the program, whenever that item in theq eueu is processed.

As you no doubt have observed, callbacks are by far the most common way that asynchronoy in JavaScrfipt
prorams is expressed and managed. Inded, the callback is the most fundamental async pattenr in the language.


Countless JS programs, even very sophisticated and compelx ones, have been written upon no other async foundation than the callback.
(with of course the concurrency interaction patterns we explored in chapte r1) The callback fucniton is the async work horse for javascript, and it does its job respectabl.

Except... Callbacks are not without their shortcomings. Many developers are excited by the PROMSE of better async patterns. But its impossible to effectively use any abstraciton if you don't
understand what its abstracting, and whyl.


Continuations:

// A
ajax( "..", function(..){
	// C
} );
// B


// A and // B represent the first half of the program (aka the now), and // C marks the second half of the program (aka the later). The first half executes right away, and then there's a "pause" of indeterminate length. At some future moment, if the Ajax call completes, then the program will pick up where it left off, and continue with the second half.

In other words, the callback function wraps or encapsulates the continuation of the program.

Let's make the code even simpler:

// A
setTimeout( function(){
	// C
}, 1000 );
// B


Stop for a moment and ask yourself how you'd descrfibe the wayt hat program behaves. 
try it out loud. Its a good exercise that will help my next points make sense.


Most readres just now probably thought or said something to the effect of: "Do A, then set up a setTimeout
to wait1,000 milliseconds, then once that fires, do c. How close was your rendition?

You might have cauvht yourself and self-edited to: "do A, setup the timeout for 1,000 milliseconds, then
do b, then after the timeout fires, do C. Thats more accurate thatn the first version


Even though the second version is more accurate, both versions are deficient in explaining this code
in a way that matches our brains to the code and the code to the JS engine. The disconnect is both subtle and monumental.
and is at the very herat of understanding the shortcomings of callbacks as async expression and management.

As soon as we introduce a single fcontiuation. In the ofrm of a callback function, we have a allowed a divergence
to form between how our brains work and the way th ecode will operate. Any time these two diverge (and this is by far no the only place that happens,)
we run into the inevitable fact that our code becomes harder to udnerstand, reason about, debug, and maintain.


Sequential Brain:
I'm pretty sure most of your readeres have heard someone say "i'm a multitasker" The effects of trying to act
as  a multitasker range from humorous to mundane to downright dangerous.

But are we multitaskers? Can we really do two conscious, intentional actions at once and think/reason about both of htem at 
exactly the samem moment? Does our highest level of brain funcitonality have parallel multithreading going on?
probably not.



Thats just not really how our brains appear to be set up. We're much more single taskers than many of us would like to admit.
We can really only think about one thing at anygiven instant.

I'm not talking about all our invaluntary, subconciuos, automatic brain functions, suchas heart beating, breathing, and eyelid blinking.
Thes are all vital tasks to our sustained life, but we don't intentionally allcoate any rbain power to them.
Thankfully, while we obsses about checking social network feeds for the 15th time in three minutes, our brain carries on in the background (Threads!) 
withall those important tasks.

WE're instead talking about whatever task is at the forefront of our minds at the moment. For me its writing the text in this book right now.
Am I doing any other higher level brain function at exactly this same moement? Nope, not really. I get disttracted quickly and easily -- a few
dozen times in thes last couple of paragraphs!

WHen we fake multitasking, such as trying to type something at the same ttime we're talking to a friend or family emmeber on the phone,
what we're actually most likely doing is acting as fast context switchers. In other words, we switch back and forth bewtween two or more tasks in rapid succession, 
simultaneously progressing on each task in tiny, fast little cunks. We do it so fast that to the outside world it appears as if we're doing those things in parallel.

DSoes that sound suspiciously like async evented concurrency to you?
If not, go back and read chapter 1 again!

In fact, one way of simplifying, the massively complex world of neurology into somethign I can remotely hope to discuss here is that our brains work kind like the event loop queue.

If you think about every single letter or word I type as a single async event, in jsut this sentence alone there are severeal dozen opportunities for my brain to be interrupted by some tother event, 
such as from m y sense, or even just my random thoughts.

I don't get interrupted and pulled ot another "process" at every oppporutnity that I could be.
But it happens often enough that I feel my own brain is nearly constanlty switching to variou sdifferent contexts and thats an awful lot like howt he js engine would probably fel.


DOING VS PLANNING:
Ok so our brains can thought of as operating in single threaded event loop queue like ways, as can the JS engine.
But we need to be more nuanced than that in our analysis. There's a big, observable difference between how we plan various tasks,
and how our brains actually operate those tasks.

Again, back ot the wriitng of htis text as my metahpor,. My rough mental outline plan here is to keep wriitng and writing,
going sequentially through a set of points I have ordered in my thoguhts. I don't plan to have any interruptions or nonlinear activity in this wriitng.
But yeet, my brain is nevertheless swithcing around all the time.

Even though at an operational level our brains are async event3ed, weseem to plaln out tasks in a sequqneial synchronous wayl. "i nee to go to the store then buy some ilk, then drop off my dry cleaning".

You'll noce that this higher level thinking doesn't seem very async event3ed in its formulation.
In fact, its kidn of rare for us to delibterately think solely in terms of events. Intead, we lan things out carefully, sequentially,
and then we assume to an extrent a sort of temporal blocking that forces b to wai t on A and c to wa it on B.

When a developer writews code, they are planning out a set of actions to occur. If htey're any good at being a developer, they're carefully planning it out. I need to set z to the value ofx, then x to the value of y and so forth..
z = x;
x = 7;
y = x;

These three assignment statements are synchronous, so x=y waits for x=x to finish, and y = z in tyrn ways for x=7 to finish. 
Another way of saying it is that these three statements are temporarily bound to execute in a certain order, one right after the other. Thankfully, we don't need to be bothered with any async evented details here.

So if synchronous brain planning maps well to synchronous code statement,s how well do our brains at planning out asynchronous code?
It turnms out how we express asynchronoy in our code doesn't map very well at all to that synchronous brain planning behavior.

We think in step by step terms, but the tools (callbacks) available to us in code aren ot expressed in a step by step fashion once we move from synchronous to asynchronous.

And THAT is why its so hard to accurately author and reason about async JS code with callbacks:
because thats now how our pbrain planing works.
Note: The only thing worse than not knowing why some code breaks is not knowing why it worked in the first place! It's the classic "house of cards" mentality: "it works, but not sure why, so nobody touch it!" You may have heard, "Hell is other people" (Sartre), and the programmer meme twist, "Hell is other people's code." I believe truly: "Hell is not understanding my own code." And callbacks are one main culprit.



Nested/Chained callbacks:
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
				handler();
			}
			else if (text == "world") {
				request();
			}
		} );
	}, 500) ;
} );

Threres a good chance code like that is recognizable to you. WE've got a chian of three funcitons ensted together, each one representing a step in an asynchronous series.


This kidn of code is often called "callback hell" and sometimes also referred to as the pyramid of dooml.

But callback hell actually has almost nothing to do with the nesting/inentatin. Its a far deeper problem than that. We'll see how and why as we continue through the rest of this chapter.

FIrst we're waiting for the "click" event, then we're waiting for hte timer to fire, then we're waiting for hte ajax repsponse to come back ,and which point we might do it alla gian.


listen( "click", handler );

function handler() {
	setTimeout( request, 500 );
}

function request(){
	ajax( "http://some.url.1", response );
}

function response(text){
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}

This formulation of the code is not hardly as recognizxable as hagving the nesting/indentation woes of its previous form,
and yet its every bit as suceptible to"callback hell". WHy?

As we go linearly (sequentially reason) about this code, we have to skip from one function to hte next,
to the next, and bounce all around the code base to see the qsequence flow.
As remember, this is simplified code in sort of best-case fashion, We all know that real async JS p[rogram code bases are
often fantastically more jmbled, which makes such reasoning order of magnitude more difficult]


Another thing to noice: to get steps 2,3, and 4 linked together so they happen in succession, the noly affordance callbacks alone
gives us to hardcore step 2 into step 1, step 3 into step 22, step 4 into step 3 asnd so on. The hardcoding isn't necessarily a bad thing, if it
really is a fixed condition that step 2 should always lead to step 3.

But the hardcoding defnitely makes the code a bit more brittle, as it doesn't account for angything going wrong
that might cause a edeviation int he progression of steps. For exapmle, if step 2 fails, step 3 never gets reached, nord oes step 2 retry, or move ot an alternate error handling flow, and so on.


All of these issues are things you CAN manually hardcode into each step, but that code is often very repetetive and not reuseable in other steps or in other async flows in your program.

Even though our brains might plan out a series of tasks in a sequential type of way (this, then this, then this) the evented nature of our brain operation makes recovery retry forking of flow control almsot efortless.
If you're out r unning errands, and you realize you left a shoppin glist at home, it doesn't end the day b ecause you didn't plan that ahead of itme. your brain routes aroudn this hiccup easily: you got home, get a list, then head right back out to the store.


But the brittle nature of manually hardocded callbacks (even with haredcoded error handling) is often far less graceful. Once you end up speciiying (aka preplaning) all the various eventulaities/paths,
the code becomes so convoluted that it s hard to ever maintain or update it.

THAT is what "callback hell" is all about! The nesting/indentation are basically a side show, a red herring.

And as if all thats not enough, we haven't even touched what happens hen two or more chains of thse callback contiuatinos are happening SIMULATANEOUSLY, or whent eh third step branches out in "parallel" callbacks
with gates or latches/



Trust ISSUES:
The mismatch between sequential brain planning and callback driven async js code is the only part o the problem wit h callbacks. Theres somethign muchd eeper to be concerned about.

// A
ajax( "..", function(..){
	// C
} );
// B

// A and // B happeng NOW, under the direct control of the main JS program. but //c gets deferred to happen later, and udner the contorl of anothe rparty -- in this case, the ajax(..) funciton. In a basic sense,
that sort of hand-off of o control doesn't regularly cause lots of problems for programs.


But don't be fooled by its infrequency that this control switch isn't a bitg deal. in fact, its one of the worst (and yet most subtle) problems
about callbacjk-driven design. It reolves around the idea that sometimes 
the party that hnaldes your callback contuation is not a function that you wrote, or that you direclty control.
Many times, its a utility provided by some third party.

WE call this "inversion of control", when you take part o fyour program and give control of its executiont o another third party. There's an unspoken
"contract" that e4xists between your code and the third party utility -- a set of htings youe xpect to be maintained.


Tale of five callbacks:
It might noe bt terribly obvious why this is such a big deal. Let me construct an exaggerated scenario to illustrate the hazards of trust at play.

IMagine yoiu're a developer taske with building out an ecommerce checkout system for a site that sells expesnive TV's. You alreaedy have all the various pages of the checkout stystem builto ut just fine.
 On the last page, when the user clicks "confirm" to buy the TV, you need to call a third-party function so that the sale can be tracked.

 You noticve that htye've provided what looks like an asynct racking utility, probably for the sak eof performance best practices, which means you need to pass in a callback funciton. in this contiunation that you pass in,
 you will have the final code that charges the customer's cr3edit card and dislays the thank yo upage.

 analytics.trackPurchase( purchaseData, function(){
	chargeCreditCard();
	displayThankyouPage();
} );

Easy enough, right? You write the code, test it, eerything works, and you deploy to production> everyone's happy.

Six months go by anad no isues. You've almost forgotten you even wrote that code. Once morning you're at a coffee shop before work, casually enjoyuing your latte, when you get pacnkicked clal form your boss
insisting you drop the coffe and rush into work right away.

When you arrive, you'll findo ut that high profile customer has his credit card charrged five times for the same tv, and he's understandbly upset. CUstomer service has already issued
an apology and processed a refund. But your boiss demsnds to know how this could possibly have happened. "don't we have tests for stuff like this?"

YOu don't even rememebr the code you wrote. But you dig back in and start trying to find out what could ahve gone awry.

AFter digging through some logs, you come to the conclusion that the only explanation is that the analytics utilty somehow, for some reason, called your callback five times tinstead of once. Nohting in their documentation mentions anything baout this.

Frustratec,you ocontat customer support, who of course is as astonished as you are. They agree to escalate it to their developers and promose to get back to you.
The next day, you recive aq lenghty email explaining what they found, which you promptly forward to your boss.

Apparently, the developers at the analytics companyh had been working on some experimetnba code that, uner ertain conditions, would retry to the provided callback once per second, for five seconds, before fialing with a timeout.
They had never inteded to push that into production, but somehow they did, and they're totally embarassed and apologetic. They go into plenty of detail about how they've
identified the breakdown adn what they'll do to ensure it enver happens again.yadda, yadda.
Whats next?

YOu talk it over with your boss, but hes not feeling particularly comfortable witht eh state of things. he insi9sts, and you reluctantly agree, taht you fan't trust tthem anymore
and that you'll need to figure out how to protect hte checkout code from such a vulnerability again.


Example code for tracking checkouts.
var tracked = false;

analytics.trackPurchase( purchaseData, function(){
	if (!tracked) {
		tracked = true;
		chargeCreditCard();
		displayThankyouPage();
	}
} );

But one of your WA engineers asks "What happen sif they never call the callback? Oops. Neitehr of you had thought about that.

You beging to chase down the rabbit hole, and think of all the possible things that could go wrong weith them calling your callback.
Here's roughly the list you come up with of ways the analytics utility could misbehave:

	Call the callback too early (before its been tracked)
	Call the callback too late (or never)
	call the callback too few or too many times (like the problem you encountered!)
	Fail to pass along any necessary environment/parameters to your callback.
	Swallow any errors/exceptions that may happen.

That hsould feel like a troubling list, because it is. You're probably slowly starting to realize that you're going to have to invent an awful lot of ad hoc logic in each and every single callback
thats passed to a utility you're not positive you can trust.
Now yo realize a bit more completely just how hellish "callback hell is"


Not just others code:
Some of you mayu be skeptical at this point whether this is as big a deal as i'm making it out to be. Perhaps you don't interact wiht truly third-party utilities much if at all.
Herpahs you use version APIS or self-host such lirbaries, sot aht tis behavior can't be changed out from underneath you.

So contemplate this: can you even REALLY trust utilities that you do theoretically control in your own code base?

Think of it this way: most of us agree that at least to some extent we should bulid our own internal functions ith some defensive checks ont he input parameters,  to reduce/prevent uenxepcted issues.

function addNumbers(x,y) {
	// + is overloaded with coercion to also be
	// string concatenation, so this operation
	// isn't strictly safe depending on what's
	// passed in.
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// "2121"

Defensive version of code:
function addNumbers(x,y) {
	// ensure numerical input
	if (typeof x != "number" || typeof y != "number") {
		throw Error( "Bad parameters" );
	}

	// if we get here, + will safely do numeric addition
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// Error: "Bad parameters"




However you go about it, these sorts of checks/normalizations are failry common on fucntion inputs, evne with code we theoretically entirely trust. IN a crude sort of way, its like the programming equivalent of the geopolitical principle fo "trust but verify"

So doesn't it stadn to treason that we should do the same thing about the copmosition of async funciton callbacks, not just with truly external code but even with code we know is generall udner our own control? OF COURSE WE SHOULD.

