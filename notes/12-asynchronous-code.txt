Asynchronous code
Introduction:
Since javascriptg is the language of the web, thre are some functions that by necessity are goingt o take a decent
amount of itme to cpmlete, sucha s fetching data from a server to display on your site. For this reason, jagvascdript includes
support for asynchrounous functions, or to put it another way, functions that can happen in the background while the rest of your code executes.

Lesson OVerveiw:
This section contains a general overview of topics you will learn in this lesson. Explain what a callback is
explain what a promise is
explain the circumsttance which promises are better than clalbacks
explain the .then() functions

Callbacks:
In the recent past, the way that these were most commonly handled were with callbacks, and even now they are stil use
quite a lot in certain circumstances.
A callback fucniton is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or aciton.

Callbacks are functions that get passed into other functions.

For example:
    myDiv.addEventListern("click", function()){
    DO SOMETHINGGG
    }

Here, the function addEventListern() takes a callback ("the do something" funciton) and then aclls it when myDiv gest clicked>
YOu will likely recognize htis pattern as something that hpapens all the time in javascript code.
Unfortuantely, though they are useful in situations like the above example,Â using callbacks can get out of hand, especially when you need to chain several of htem together in a specific
order. the rest of htis lesson discusses pattersn and functions that will help keep you out of callback hell.

Promises:
There are multiple ways that you can handle asynchronous code in JavaScrfipt, and they all have their use cases.
Promises are one such mechanism, and they're on you will see somewhat often when using other libraries or frameworks. Knowing 
what thye are and how to use them is quite useful.

Essentially, a promise is an object that might produce a value at some point in the future.

Lets say getData()is a function that fetches some data from a server and retunrs it as on object that we can use in our code:

const getData = function() {
    //go fetch data from some APi
    //clean it up a bit return it as an object
    return data.
}
The issue with this example is that it takes some time to fetche the data, but unless we tell our code that, it assumes that everything in the funciton happens essentially instantly.

So if we try this:
const myData = getData()
const pieceOfData = myData["whatever"]

WE're going to run into trouble because when we try to extract pieceOfData out of the returned data,
the funciton getData() will mostlikely still be fetchingh, so myData will not be the expected data,
but will be undefined. Sad.

We need some way to solve this problem, and tell our code to wait until the data is done fetching to continue. Promises solve this issue. 



const myData = getData() //if this is refactored to return a promise...


myData.then(function(data) [//.,then() tell is to wait until the promise is resolved
    const pieceOfData = data["whatever]//and THEN run the function inside.
])



Article:https://davidwalsh.name/promises

While synchronous code is easeir to follow and debug, async is generally ebtter for performance and flexiibility.
Why "hold up the show" when you can trigger numerous requests at once and then handle them when each si ready?
Promsies are becoming a big part of the javascript world, with many new APIS being implemented witht hep rmose philosophy.


Promises in the wild:
The XMLHttpRequest API is async but does NOT use the promises API. TGhere are a few native apis that now use promises however.
    Battery API
    fetch API
    ServiceWorker API

Promises will only become more prevalent so its important that allf ront-end developers get used to them.
Its also worht noting that node.js is another platform for promises. Obviously as promise is a core language features.

Basic Promise Usage:
The new Promise() constructor should only be used fo rlegacy async tasks, like the usage of setTimeout or XMLHttpRequest. 
AA new promsie is created with the new keyword and the promise provides resolvea dn reject funcitons to the provided callback:

var p = new Promise(function(resolve, reject) {
	
	// Do an async task async task and then...

	if(/* good condition */) {
		resolve('Success!');
	}
	else {
		reject('Failure!');
	}
});

p.then(function(result) { 
	/* do something with the result */
}).catch(function() {
	/* error : */
}).finally(function() {
   /* executes regardless or success for failure */ 
});



Sometimes you dont NEED to complete an async takss within the promise.
returning a promise will be best so taht you can always count on ap romise coming out of a given fucniton.
IN that case, you acn simply call promise.reolve() of promise.reject() without using the new keyword


Callbacks: https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/async%20%26%20performance/ch2.md

IN chapter 1, we explored the terminology adn concepts around asynchronous programming in javascript.
Our focus is onudnerstandint he single-threaded (one at a time) event lop queue that
drives all events. WE also explored vairous ways that concurrency pattersn explains the relationshipos
between any simultaneously running chains of events, or processes.

All oru examples in chapter 1 use the funciton as the individual, indivisible unit of operations, whereby inside
the funciton, statements run in predictrable order ( above the ocmpiler level) but at the
funciton ordering level, events (aka async funciton invocations) can happen in a variety or ordres.

In all these cases, the funciton is a cting as a "callback" because it serves as the target for the event loop
to "call back into" the program, whenever that item in theq eueu is processed.

As you no doubt have observed, callbacks are by far the most common way that asynchronoy in JavaScrfipt
prorams is expressed and managed. Inded, the callback is the most fundamental async pattenr in the language.


Countless JS programs, even very sophisticated and compelx ones, have been written upon no other async foundation than the callback.
(with of course the concurrency interaction patterns we explored in chapte r1) The callback fucniton is the async work horse for javascript, and it does its job respectabl.

Except... Callbacks are not without their shortcomings. Many developers are excited by the PROMSE of better async patterns. But its impossible to effectively use any abstraciton if you don't
understand what its abstracting, and whyl.


Continuations:

// A
ajax( "..", function(..){
	// C
} );
// B


// A and // B represent the first half of the program (aka the now), and // C marks the second half of the program (aka the later). The first half executes right away, and then there's a "pause" of indeterminate length. At some future moment, if the Ajax call completes, then the program will pick up where it left off, and continue with the second half.

In other words, the callback function wraps or encapsulates the continuation of the program.

Let's make the code even simpler: