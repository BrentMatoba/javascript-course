First off, Modules are NOT the same thing as the module pattern we previously discussed.
ES6 Modules are basically the import/export functions from other languages. Its exaclty what you would expect.


Before we can REALLY use modules, we're going to have to learn about NPM and webpack, which are both topics that are VERY useful
to you even beyond this lesson. In the end, the modules themselves are simple to implement, so we're going to take this ch ance to learn
about a few other things.


Lesson Overview:
    This section contains a general overview of topics that you will learn in this lesson.
    
    Explain what NPM is and where itw as commonly used before being adopted in the frontend.
    Describe what npm init and what package.json is
    Know how to install packages using npm
    describe what a javascripot module bunder like webpack is.
    Explain what the concepts "entry" and "output" mean in relation to webpack.
    Briefly explain what a development dependency is.
    Explain what "transpiling code" means and how it relates to front-end web development.
    Briefly describe what a task runner is and how its used in front end development.
    Describe how to write an npm automation script.
    Explain one of the main benefits of writing code in modules.
    Explain "named" exports and "default" exports.


This history of Javascript.
    Why do we even need or want htis stuff? what do you gain from all this added complexity?  These are good questions...with good answers.
    Using a javascript package manager (npm)
        Starting around 2010, several competing javascript package managers emerged to hlep automate the process of downloading and upgrading libraries from
        a central repository. Bower was arguably the most popular in 2013, but eventually was overtaken by npm aroudn 2015.
        (its worth noting that starting around late 2016, yarn has picked up a lot of traction as an alternative to npm's interface, but it still uses npm packages under the hood)

        Note that npm was originally a package manager made specifically for node.js, a javascript runtime designed to run ont he server, not the frontend. So that
        makes it a pretty weird choice for a frontend javascript package manager for libraries meant to run in a browser.


    Using a javascript module bundler(webpack)
        Most programming languages provide a way to import code from one file into another. Javaascript wasn't originally designed
        with this feature, because javascript was designed to only run in the browser, with no access to the file system of the client's computer.(for security reasons)
        So for the longest time, organizing javascript code in multiple files required you to load each file with variables shared globally.

        This is actually what we'r edoing with the above moment.js example. The entire moment.min.js file is loaded in the HTML, which defines a global variable "moment",
        which is then available to any file loaded after moment.min.js (regardless of whether or not it needs access to it.)

        In 2009, a project nammed CommonJS was started witht he goal of specifying an ecosystem for JavaScript outsdie the browser. A big part of CommonJS was its specification
        for modules, which would finally allow Javascript to import and export code across files like most programming languages, without resorting to global variables.
        THis most well-known of implementation of CommonJS modules is node.js



        Node.js is a tool for running JavaScript code outside of a web browser. It lets you build things like websites and apps using JavaScript. Node.js is popular because it's fast
         and can handle lots of users at the same time. It works well for online games, chat applications, and other interactive websites.