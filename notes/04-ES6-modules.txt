First off, Modules are NOT the same thing as the module pattern we previously discussed.
ES6 Modules are basically the import/export functions from other languages. Its exaclty what you would expect.


Before we can REALLY use modules, we're going to have to learn about NPM and webpack, which are both topics that are VERY useful
to you even beyond this lesson. In the end, the modules themselves are simple to implement, so we're going to take this ch ance to learn
about a few other things.


Lesson Overview:
    This section contains a general overview of topics that you will learn in this lesson.
    
    Explain what NPM is and where itw as commonly used before being adopted in the frontend.
    Describe what npm init and what package.json is
    Know how to install packages using npm
    describe what a javascripot module bunder like webpack is.
    Explain what the concepts "entry" and "output" mean in relation to webpack.
    Briefly explain what a development dependency is.
    Explain what "transpiling code" means and how it relates to front-end web development.
    Briefly describe what a task runner is and how its used in front end development.
    Describe how to write an npm automation script.
    Explain one of the main benefits of writing code in modules.
    Explain "named" exports and "default" exports.


This history of Javascript. https://peterxjang.com/blog/modern-javascript-explained-for-dinosaurs.html
    Why do we even need or want htis stuff? what do you gain from all this added complexity?  These are good questions...with good answers.
    Using a javascript package manager (npm)
        Starting around 2010, several competing javascript package managers emerged to hlep automate the process of downloading and upgrading libraries from
        a central repository. Bower was arguably the most popular in 2013, but eventually was overtaken by npm aroudn 2015.
        (its worth noting that starting around late 2016, yarn has picked up a lot of traction as an alternative to npm's interface, but it still uses npm packages under the hood)

        Note that npm was originally a package manager made specifically for node.js, a javascript runtime designed to run ont he server, not the frontend. So that
        makes it a pretty weird choice for a frontend javascript package manager for libraries meant to run in a browser.


    Using a javascript module bundler(webpack)
        Most programming languages provide a way to import code from one file into another. Javaascript wasn't originally designed
        with this feature, because javascript was designed to only run in the browser, with no access to the file system of the client's computer.(for security reasons)
        So for the longest time, organizing javascript code in multiple files required you to load each file with variables shared globally.

        This is actually what we'r edoing with the above moment.js example. The entire moment.min.js file is loaded in the HTML, which defines a global variable "moment",
        which is then available to any file loaded after moment.min.js (regardless of whether or not it needs access to it.)

        In 2009, a project nammed CommonJS was started witht he goal of specifying an ecosystem for JavaScript outsdie the browser. A big part of CommonJS was its specification
        for modules, which would finally allow Javascript to import and export code across files like most programming languages, without resorting to global variables.
        THis most well-known of implementation of CommonJS modules is node.js



        Node.js is a tool for running JavaScript code outside of a web browser. It lets you build things like websites and apps using JavaScript. Node.js is popular because it's fast
         and can handle lots of users at the same time. It works well for online games, chat applications, and other interactive websites.



NPM
    What is NPM?
    Node Package Manger is a command-line tool that gives you access to a gigantic repository of plugins, libraries, and tools. 

    NPM consists of three distinct components:
        The websites
        The command line interface(CLI)
        The registry

        Use the WEBSITE to discover packages, set up profiles, and manage other asepcts of your npm experience.
         For example, you can set up organizations to manage access to public or private packages.
         The CLI runs from a terminal, and is how most developers interact with npm.
         the REGISTRY is a large public database of javascript software and the meta-information surrounding it.

         Use NPM to:
            1. Adapt packages of code for your apps, or incorporate packages as they are.
            2. Download standalone tools you can use right away.
            3. Run packages without downloading using npx.
            4. Share code with any npm user, anywhere.
            5. Restrict code to specific developers.
            6. Create organizations to coordiante package maintenance, coding, and developers.
            7. Form vritual teams by using organizations.
            8. Manage multiple versions of code and code dependencies.
            9. Update applications easily when underlying code is updated.
            10. Discover multiple ways to solve the same puzzle.
            11. Find other deevelopers who are working on similar problems and projects.

Package.json files
    A package.json file is used in Node.js projects to manage project settings. It's a simple file in JSON format that contains information like the project's name, version, dependencies 
    (other code it needs to run), scripts, and more. This file helps others understand your project and lets you easily manage what code your project needs to run.

Demystifyign Devdependencies and dependencies https://dev.to/mshertzberg/demystifying-devdependencies-and-dependencies-5ege
    If you aren't familiar, devDependencies and dependencies are two properties that are added to package.json when a package is installed as a developmental dependency or a production dependency, respectively.
    In the NPM ecosystem, packages are installed and consumed by requiruing them or importing them in files, or ru in the command-line as binaries. When an application is fed into a module bundler,
    like webpack or rollup, all required dependencies are pulled together and bundled (as the naem suggests) you should ensure that these packages are present in dependencies, as they're needed at runtime.

    Development Dependencies, or devDependencies are packages that are consumed by requiring them in files or runas binaries, during the development phase. THese are packages that are only necessary during development
    and not necesary for the production build. Some examples of packages hatwould only be required during development are babel plugins and presets, test runners, and linter packages.

    Alternatively, there is a dependency that is necessary in both production adn development. In this case, it can be added to depdencies, since dependencies are available in both production and developemnt.


In a package.json file for Node.js projects, "dependencies" are the packages your project needs to run, like libraries or frameworks. "devDependencies" are packages used only during development, like testing tools or compilers, and aren't needed for the project to run after it's built.




Yarn:
    At some pinot, you will probably run into Yarn, a replacement for hte default npm. for the most part, it does the same things, though it does have a few more features. Recent versions of npm have incorporated some of the best features of Yarn,
    so using it won't off you any real advantages at thsi point in your carrer. It is a fine package manager however, and may be worht your consideration in teh future.


Webpack and bundlers
    Sofar your projects have had relativey basic file structures. As project complexity grows, so too will the benefits of well-organized code. A project consisteing of a single, long file with lots of code can be made
    easier to navigate and maintain by being broken down into multiple smaller files (modules) Futher benefits of writing code in modules will come below when we introduce Es6 modules.

    But theres a problem! THe browser would need to maek a separate HTTP request for each file. The more files you ahve, the more costly this becomes, particularly on slower networks and would only increase if you also imported third-party libraries into your app.
    What if we had a wayt ow rite multiple files ande/or import multiiple third-party libraries but eventually combine them all into fewer fiels at the end os that broswer did not have ot maek so many requests?