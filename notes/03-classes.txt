Classes in Javascript.

So techncially Javascript does NOT have classes in the same way as Java or Ruby. However, ES6 did introduce syntax
for object creation using the class keyword. On the surface, its the exact same as traditional Object Oriented Programming languages.
However, its an important distinction that they are differet systems under the hood, and that there are potential problems
that can arise from assuming that ES6 classes operate like traditional OOP classes. Opponents argue that the Javascript
Es6 class system is syntactic sugar that can be potentially dangerous and misleading.

Despite the controversy, classes are beginning to crop up in real code bases.
THe people at the Odin Project approve of classes and think they are fine to use.
However I SHOULD learn how to use prototypes as well, I can't use classes just because they're comfortable.

Lesson Overview:
Describe the pros and cons of using classes in Javascript
Briefly Discuss how Javascript's object creation differs from a language like Java or Ruby
Explain the differences between an object constructor and a class.
Explain what "getters" and "setters" are.
Explain how to implement private class fields and methods.
Describe function binding.
Use Inheritance with classes.
Understand why composition is generally preferred to inheritance.



1. Property getters and setters:
    There are two kinds of object properties.
        a. data properties.
            self explanatory

        b. accessor property:
            Functions that execute on getting and setting a value, but look like regular properties to an external code.

            let obj = {
                get propName(){
                    //getter, the code executed on getting obj.propName
                }
                set propName(value){
                    //setter, teh code executed on setting obj.propName = value;
                }
            }   

    The getter works when obj.propName is read, the setter - when it is assigned.

    For instance: We have a user with a first and last name, and we want to return the full name.
    let user = {
        name: "John",
        surname: "Smith"
    };

      get fullName() {
            return `${this.name} ${this.surname}`;
    }

    //this is the setter.
    set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }


2. Accessor Descriptors
    Descriptors for accessing properties are different from those for data properties.
    For accessor properties, there is no value or writeable, but instead there are get and set functions.

    That is, an accessor descriptor may have
        get: a function without arguments, taht works when a property is read.
        set: a function with one argument, that is called when the property is set.
        enumberable: same as for data properties. (What does this mean lol)
        configurable: same as for data properties.

3. Smarter getters/setters:
    Getters/setters can be used as wrappers over "real" property values to gain more control over operations with them.
    For instance, if we want to forbid too short names for user, we can have a setter name and keep the value in a separate property.

    So the name is stored in the _name property, and the access is done via getter and setter. Technically, external code is able to access
    the name directly by user._name. But there is a widely known convention that properties starting with an underscore _ are internal and
    should not be touched from outside the object.

4. Using for compatibility:
    One of the great uses of accessors is that they allow to take over a "regular" data property at any moment by replacing it
    with a getter and a setter and tweak its behavior. Imagine we started implementing user objects using data properties name and age:

    function User(name, age) {
        this.name = name;
        this.age = age;
    }

    let john = new User("John", 25);

    alert( john.age ); // 25

    but later, things change. Instead of age we want to store birthday, because its more precise and convenient.
    function User(name, birthday) {
        this.name = name;
        this.birthday = birthday;
        }

    let john = new User("John", new Date(1992, 6, 1));

    now what should we do wit the old code that still uses age property? We can try to find all such places and fix them, but that takes time and can be hard to do.
    if that code is used by many other people. And beides, age is a nice thing to have in user, right?
    lets keep it. Adding a getter for age solves the problem.





    Article: https://javascript.info/class
    1. In practice, we often need to create many objects of the same kind, like users, or goods or whatever. The new function can help with that.
    However, in modern Javascript, there's a more advanced "class" construct, that introduces great new features which are useful for object-oriented programming.

    The "class" syntax
    the basic syntax is:
        class myCLass {
            //class methods
            constructor(){...}
            method1(){...}
            method2(){...}
            method3(){...}
            ...
        }

        then use new myClass() to creatge a new object with all the listed methods.
        the constructor() method is called automatically by new, so we can initialize the object there.

    For example:
    class User{
        constructor(name){
            this.name = name;
        }
        sayHi(){
            alert(this.name);
        }
    }    

    //usage
    let user = new User("John");
    user.sayHi();

    When new User("John") is called:
        1.A new object is created.
        2. The constructor runs with the given argument assigns it to this.name;
        then we can call object methods, such as user.sayHi();
    


    2. What is a class?
        So what exactly is a class? there not an entirely new language-level entity, as one might think.
        Lets unveil any magic and see what a class really is. That'll help in understanding many complex aspects. In jhavascript, a class is a kind of function.
        class User{
            constructor(name) {this.name = name;}
            sayHi(){alert(this.name);}
        }

        alert(typeof User);

        What class User {...} construct really does is:
            a. Creates a function named User, that becomes the result of the class declaration. The function code is taken from the constructor method.
            (assumed empty if we don't write such method.)
            b. STores class methods, such as sayHi, in User.prototype.

            After new User object is created, when we call its method, its taken from the prototype. So the object has access to class methods.
    
    3. Not just Synctactic Sugar.
        a.Sometimes people say that class is a "syntactic sugar" (syntax that is designed to make things easier to read, but doesn't iintroduce anything new),
        because we could actually declare the same thing without using the class keyword at all:

        //rewriting class User in pure functions

        //a. Create constructor function
        function User(name) {
            this.name = name;
        }
        //a function prototype has "constructor" property by defualt,
        //so we don't need to create it.

        b.Add the method to prototype
        User.prototype.sayHi = function(){
            alert(this.name);
        }
        ;

        //Usage:
        let user = new User("John");
        user.sayHi();
        
        b.The result of this is aboutthe same. Sot here are indeed reasons why class can be considered a syntactic sugar to define a constructor together with its prototype methods.
        Still, there are important differences.
            1. First, a function created by class is labelled by a special internal property [[IsClassConstructor]]: true.
            So its not entirely the same as creating it manually.
            The language checks fro that property in a variety of places. For example, unlike a regular funciton, it must be called with new:
            Also, a string representation of a class constructor is most Javascript engines starts with the "class..."
            There are other differences, we'll see them soon.

            2. Class methods are non-enumerable. A class definition sets enumerable flag to false for all methods in "prototype"
            that's good! because if we for...in over an objectg, we usually don't want its class methods.

            3. Class always use strict. All code inside the class construct is automatically in strict method.
            Besides, class syntax brings many other features that we'll explore later.
